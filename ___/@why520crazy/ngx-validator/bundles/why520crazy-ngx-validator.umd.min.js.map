{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@why520crazy/ngx-validator/validator.class.ts","ng://@why520crazy/ngx-validator/strategies/noop-validation-feedback-strategy.ts","ng://@why520crazy/ngx-validator/strategies/bootstrap-validation-feedback-strategy.ts","ng://@why520crazy/ngx-validator/strategies/index.ts","ng://@why520crazy/ngx-validator/validator-loader.service.ts","ng://@why520crazy/ngx-validator/message-transformers.ts","ng://@why520crazy/ngx-validator/validator.service.ts","ng://@why520crazy/ngx-validator/directives/form-validator.directive.ts","ng://@why520crazy/ngx-validator/directives/form-submit.directive.ts","ng://@why520crazy/ngx-validator/validators.ts","ng://@why520crazy/ngx-validator/directives/validators.ts","ng://@why520crazy/ngx-validator/module.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","NGX_VALIDATOR_CONFIG","InjectionToken","DEFAULT_GLOBAL_VALIDATION_MESSAGES","required","maxlength","minlength","ngxUniqueCheck","email","repeat","pattern","number","url","max","min","NoopValidationFeedbackStrategy","prototype","showError","element","errorMessages","removeError","INVALID_CLASS","INVALID_FEEDBACK_CLASS","BootstrapValidationFeedbackStrategy","classList","add","parentElement","documentFrag","document","createDocumentFragment","divNode","createElement","textNode","createTextNode","appendChild","setAttribute","append","remove","invalidFeedback","querySelector","removeChild","ValidationFeedbackStrategyBuilder","noop","bootstrap","defaultValidatorConfig","validationFeedbackStrategy","validationMessages","NgxValidatorLoader","config","this","Object","assign","getDefaultValidationMessage","key","globalValidationMessages","defineProperty","validateOn","getErrorMessage","name","validationErrorValues","addValidationMessages","messages","setGlobalValidationMessages","Injectable","args","providedIn","Optional","type","Inject","maxOrMinLengthTransformer","message","replace","requiredLength","toString","transformerMap","maxTransformer","minxTransformer","NgxFormValidatorService","thyFormValidateLoader","_controls","validations","_getValidationFeedbackStrategy","strategy","_config","Error","_getElement","_formElement","_clearElementError","hasError","_tryGetValidation","_initializeFormControlValidation","_getControlByName","control","_this","valueChanges","subscribe","_restFormControlValidation","validation","_getValidationMessage","validationErrorName","transformMessage","validatorName","_getValidationMessages","validationErrors","validationError","hasOwnProperty","_setControlValidationError","initialize","ngForm","formElement","_ngForm","initializeFormControlsValidation","controls","forEach","find","item","onblur","event","validateControl","setValidatorConfig","_getControls","NgForm","FormGroupDirective","controls_1","directives","directive","invalid","errors","validateControls","name_1","keys","validate","$event","onSubmit","valid","reset","name_2","markControlAsError","submit","alwaysSubmit","forbidSubmit","NgxFormValidatorDirective","ngZone","renderer","elementRef","_validator","validator","ngOnInit","runOutsideAngular","unsubscribe","listen","nativeElement","onKeydown","bind","ngAfterContentInit","toArray","changes","onSubmitSuccess","submitRunInZone","run","currentInput","activeElement","which","keyCode","tagName","enterKeyMode","NgxEnterKeyMode","preventDefault","ctrlKey","metaKey","ngOnDestroy","Directive","selector","providers","exportAs","NgZone","Renderer2","ElementRef","ControlContainer","ContentChildren","NgControl","descendants","Input","NgxFormSubmitDirective","validatorDirective","ngxFormSubmit","EventEmitter","emit","Output","HostListener","NgxValidators","uniqueCheckValidator","uniqueCheckFn","pipe","map","isUnique","of","MinValidatorDirective","Validators","parseFloat","provide","NG_VALIDATORS","useExisting","forwardRef","multi","MaxValidatorDirective","NgxUniqueCheckDirective","NG_ASYNC_VALIDATORS","declarations","NgxValidatorModule","forRoot","ngModule","useValue","NgModule","imports","FormsModule","exports","__spread","arguments","length","concat"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { InjectionToken } from '@angular/core';\nimport { ValidationFeedbackStrategy } from './strategies';\n\nexport interface Dictionary<T> {\n    [key: string]: T;\n}\n\nexport declare type NgxValidationMessages = Dictionary<Dictionary<string>>;\n\nexport declare type NgxValidateOn = 'submit' | 'blur';\n\nexport interface NgxValidatorConfig {\n    validationFeedbackStrategy?: ValidationFeedbackStrategy;\n    validationMessages?: NgxValidationMessages;\n    validateOn?: NgxValidateOn;\n}\nexport interface NgxValidatorGlobalConfig extends NgxValidatorConfig {\n    globalValidationMessages?: Dictionary<string>;\n}\n\nexport const NGX_VALIDATOR_CONFIG = new InjectionToken<NgxValidatorGlobalConfig>('NGX_VALIDATION_CONFIG');\n\nexport const DEFAULT_GLOBAL_VALIDATION_MESSAGES = {\n    required: 'è¯¥éé¡¹ä¸è½ä¸ºç©º',\n    maxlength: 'è¯¥éé¡¹è¾å¥å¼é¿åº¦ä¸è½å¤§äº{requiredLength}',\n    minlength: 'è¯¥éé¡¹è¾å¥å¼é¿åº¦ä¸è½å°äº{requiredLength}',\n    ngxUniqueCheck: 'è¾å¥å¼å·²ç»å­å¨ï¼è¯·éæ°è¾å¥',\n    email: 'è¾å¥é®ä»¶çæ ¼å¼ä¸æ­£ç¡®',\n    repeat: 'ä¸¤æ¬¡è¾å¥ä¸ä¸è´',\n    pattern: 'è¯¥éé¡¹è¾å¥æ ¼å¼ä¸æ­£ç¡®',\n    number: 'å¿é¡»è¾å¥æ°å­',\n    url: 'è¾å¥URLæ ¼å¼ä¸æ­£ç¡®',\n    max: 'è¯¥éé¡¹è¾å¥å¼ä¸è½å¤§äº{max}',\n    min: 'è¯¥éé¡¹è¾å¥å¼ä¸è½å°äº{min}'\n};\n","import { ValidationFeedbackStrategy } from './validation-feedback-strategy';\n\nexport class NoopValidationFeedbackStrategy implements ValidationFeedbackStrategy {\n    /** Does nothing, as this validation message display strategy is a no-op. */\n    showError(element: HTMLElement, errorMessages: string[]): void {}\n\n    removeError(element: HTMLElement): void {}\n}\n","import { ValidationFeedbackStrategy } from './validation-feedback-strategy';\n\nconst INVALID_CLASS = 'is-invalid';\nconst INVALID_FEEDBACK_CLASS = 'invalid-feedback';\n\nexport class BootstrapValidationFeedbackStrategy implements ValidationFeedbackStrategy {\n    constructor() {}\n\n    showError(element: HTMLElement, errorMessages: string[]): void {\n        if (element) {\n            element.classList.add(INVALID_CLASS);\n        }\n\n        if (element && element.parentElement) {\n            const documentFrag = document.createDocumentFragment();\n            const divNode = document.createElement('DIV');\n            const textNode = document.createTextNode(errorMessages[0]);\n            divNode.appendChild(textNode);\n            divNode.setAttribute('class', INVALID_FEEDBACK_CLASS);\n            documentFrag.appendChild(divNode);\n            element.parentElement.append(documentFrag);\n        }\n    }\n\n    removeError(element: HTMLElement): void {\n        if (element) {\n            element.classList.remove(INVALID_CLASS);\n        }\n        if (element && element.parentElement) {\n            const invalidFeedback = element.parentElement.querySelector(`.${INVALID_FEEDBACK_CLASS}`);\n            if (invalidFeedback) {\n                element.parentElement.removeChild(invalidFeedback);\n            }\n        }\n    }\n}\n","import { NoopValidationFeedbackStrategy } from './noop-validation-feedback-strategy';\nimport { BootstrapValidationFeedbackStrategy } from './bootstrap-validation-feedback-strategy';\nimport { ValidationFeedbackStrategy } from './validation-feedback-strategy';\n\nexport class ValidationFeedbackStrategyBuilder {\n    static noop(): ValidationFeedbackStrategy {\n        return new NoopValidationFeedbackStrategy();\n    }\n\n    static bootstrap(): ValidationFeedbackStrategy {\n        return new BootstrapValidationFeedbackStrategy();\n    }\n}\n\nexport { ValidationFeedbackStrategy, NoopValidationFeedbackStrategy, BootstrapValidationFeedbackStrategy };\n","import { Inject, Injectable, Optional } from '@angular/core';\nimport {\n    NgxValidatorGlobalConfig,\n    NgxValidationMessages,\n    Dictionary,\n    NGX_VALIDATOR_CONFIG,\n    DEFAULT_GLOBAL_VALIDATION_MESSAGES\n} from './validator.class';\nimport { ValidationErrors } from '@angular/forms';\nimport { ValidationFeedbackStrategy, ValidationFeedbackStrategyBuilder } from './strategies';\n\nconst defaultValidatorConfig: NgxValidatorGlobalConfig = {\n    validationFeedbackStrategy: ValidationFeedbackStrategyBuilder.bootstrap(),\n    validationMessages: {}\n};\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class NgxValidatorLoader {\n    private config: NgxValidatorGlobalConfig;\n\n    private getDefaultValidationMessage(key: string) {\n        if (this.config.globalValidationMessages && this.config.globalValidationMessages[key]) {\n            return this.config.globalValidationMessages[key];\n        } else {\n            return DEFAULT_GLOBAL_VALIDATION_MESSAGES[key];\n        }\n    }\n\n    get validationMessages() {\n        return this.config.validationMessages;\n    }\n\n    get validationFeedbackStrategy(): ValidationFeedbackStrategy {\n        if (!this.config.validationFeedbackStrategy) {\n            this.config.validationFeedbackStrategy = ValidationFeedbackStrategyBuilder.bootstrap();\n        }\n        return this.config.validationFeedbackStrategy;\n    }\n\n    get validateOn () {\n        if (!this.config.validateOn) {\n            this.config.validateOn = 'submit';\n        }\n        return this.config.validateOn;\n    }\n\n    constructor(\n        @Optional()\n        @Inject(NGX_VALIDATOR_CONFIG)\n        config: NgxValidatorGlobalConfig\n    ) {\n        this.config = Object.assign({}, defaultValidatorConfig, config);\n    }\n\n    /**\n     * get validation error messages\n     * @param name formControl name, e.g. username or email\n     * @param key validator name, e.g. required or pattern\n     */\n    getErrorMessage(name: string, key: string, validationErrorValues?: any) {\n        let message = '';\n        if (this.validationMessages[name] && this.validationMessages[name][key]) {\n            message = this.validationMessages[name][key];\n        } else {\n            message = this.getDefaultValidationMessage(key);\n        }\n        return message;\n    }\n\n    // getErrorMessages(name: string, validationErrors: ValidationErrors) {\n    //     const messages = [];\n    //     for (const validationError in validationErrors) {\n    //         if (validationErrors.hasOwnProperty(validationError)) {\n    //             messages.push(this.getErrorMessage(name, validationError, validationErrors[validationError]));\n    //         }\n    //     }\n    //     return messages;\n    // }\n\n    addValidationMessages(messages: NgxValidationMessages) {\n        Object.assign(this.config.validationMessages, messages);\n    }\n\n    setGlobalValidationMessages(validationMessages: Dictionary<string>) {\n        this.config.globalValidationMessages = validationMessages;\n    }\n}\n","function maxOrMinLengthTransformer(message: string, validationErrorValues: { requiredLength: number }): string {\n    return message.replace(`{requiredLength}`, validationErrorValues.requiredLength.toString());\n}\n\nfunction maxTransformer(message: string, validationErrorValues: { max: number; actual: number }): string {\n    return message.replace(`{max}`, validationErrorValues.max.toString());\n}\n\nfunction minxTransformer(message: string, validationErrorValues: { min: number; actual: number }): string {\n    return message.replace(`{min}`, validationErrorValues.min.toString());\n}\n\nconst transformerMap = {\n    minlength: maxOrMinLengthTransformer,\n    maxlength: maxOrMinLengthTransformer,\n    max: maxTransformer,\n    min: minxTransformer\n};\n\nexport function transformMessage(validatorName: string, message: string, validationErrorValues: any) {\n    if (transformerMap[validatorName] && validationErrorValues) {\n        return transformerMap[validatorName](message, validationErrorValues);\n    }\n    return message;\n}\n","import { Injectable } from '@angular/core';\nimport {\n    NgForm,\n    AbstractControl,\n    ValidationErrors,\n    FormGroupDirective,\n    FormControlName,\n    NgControl\n} from '@angular/forms';\nimport { NgxValidatorLoader } from './validator-loader.service';\nimport { NgxValidatorConfig, Dictionary } from './validator.class';\nimport { transformMessage } from './message-transformers';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class NgxFormValidatorService {\n    private _ngForm: NgForm | FormGroupDirective;\n\n    private _formElement: HTMLElement;\n\n    private _config: NgxValidatorConfig;\n\n    private _controls: NgControl[] = [];\n\n    // public errors: string[];\n\n    // è®°å½ææåç´ çéªè¯ä¿¡æ¯\n    public validations: Dictionary<{\n        hasError?: boolean;\n        errorMessages?: string[];\n    }> = {};\n\n    private _getValidationFeedbackStrategy() {\n        const strategy =\n            (this._config && this._config.validationFeedbackStrategy) ||\n            this.thyFormValidateLoader.validationFeedbackStrategy;\n        if (!strategy) {\n            throw new Error(`validation display strategy is null`);\n        }\n        return strategy;\n    }\n\n    private _getElement(name: string) {\n        const element = this._formElement[name];\n        if (element) {\n            return element;\n        } else {\n            return this._formElement.querySelector(`[name='${name}']`);\n        }\n    }\n\n    private _clearElementError(name: string) {\n        if (this.validations[name] && this.validations[name].hasError) {\n            this.validations[name].hasError = false;\n            this.validations[name].errorMessages = [];\n            this._getValidationFeedbackStrategy().removeError(this._getElement(name));\n        }\n    }\n\n    _tryGetValidation(name: string) {\n        if (!this.validations[name]) {\n            this._initializeFormControlValidation(name, this._getControlByName(name));\n        }\n        return this.validations[name];\n    }\n\n    private _initializeFormControlValidation(name: string, control: AbstractControl | FormControlName | NgControl) {\n        this.validations[name] = {\n            hasError: false,\n            errorMessages: []\n        };\n        control.valueChanges.subscribe(() => {\n            this._clearElementError(name);\n        });\n    }\n\n    private _restFormControlValidation(name: string) {\n        const validation = this.validations[name];\n        if (validation) {\n            validation.hasError = false;\n            validation.errorMessages = [];\n        }\n    }\n\n    private _getValidationMessage(name: string, validationErrorName: string, validationErrorValues?: any) {\n        let message = '';\n        if (\n            this._config &&\n            this._config.validationMessages &&\n            this._config.validationMessages[name] &&\n            this._config.validationMessages[name][validationErrorName]\n        ) {\n            message = this._config.validationMessages[name][validationErrorName];\n        } else {\n            message = this.thyFormValidateLoader.getErrorMessage(name, validationErrorName, validationErrorValues);\n        }\n\n        return transformMessage(validationErrorName, message, validationErrorValues);\n    }\n\n    private _getValidationMessages(name: string, validationErrors: ValidationErrors) {\n        const messages = [];\n        for (const validationError in validationErrors) {\n            if (validationErrors.hasOwnProperty(validationError)) {\n                messages.push(this._getValidationMessage(name, validationError, validationErrors[validationError]));\n            }\n        }\n        return messages;\n    }\n\n    private _setControlValidationError(name: string, errorMessages: string[]) {\n        const validation = this._tryGetValidation(name);\n        validation.errorMessages = errorMessages;\n        validation.hasError = true;\n        this._getValidationFeedbackStrategy().showError(this._getElement(name), errorMessages);\n    }\n\n    get validatorConfig() {\n        return this._config;\n    }\n\n    constructor(private thyFormValidateLoader: NgxValidatorLoader) {}\n\n    initialize(ngForm: NgForm | FormGroupDirective, formElement: HTMLElement) {\n        this._ngForm = ngForm;\n        this._formElement = formElement;\n    }\n\n    initializeFormControlsValidation(controls: NgControl[]) {\n        if ((this._config && this._config.validateOn === 'blur') || this.thyFormValidateLoader.validateOn === 'blur') {\n            (controls || []).forEach((control: NgControl) => {\n                if (!this._controls.find(item => item.name === control.name)) {\n                    this._initializeFormControlValidation(control.name, control);\n                    const element: HTMLElement = this._getElement(control.name);\n                    if (element) {\n                        element.onblur = (event: FocusEvent) => {\n                            this.validateControl(control.name);\n                        };\n                    }\n                }\n            });\n            this._controls = controls;\n        }\n    }\n\n    setValidatorConfig(config: NgxValidatorConfig) {\n        this._config = config;\n    }\n\n    private _getControls() {\n        if (this._ngForm instanceof NgForm) {\n            return (this._ngForm as NgForm).controls;\n        } else if (this._ngForm instanceof FormGroupDirective) {\n            const controls = {};\n            (this._ngForm as FormGroupDirective).directives.forEach(directive => {\n                controls[directive.name] = directive;\n            });\n            return controls;\n        }\n    }\n\n    private _getControlByName(name: string): AbstractControl | FormControlName {\n        const controls = this._getControls();\n        return controls[name];\n    }\n\n    validateControl(name: string) {\n        this._clearElementError(name);\n        const control = this._getControlByName(name);\n        if (control && control.invalid) {\n            const errorMessages = this._getValidationMessages(name, control.errors);\n            this._setControlValidationError(name, errorMessages);\n        }\n    }\n\n    validateControls() {\n        // ä¸»è¦æ¯ æ æ³æ£æµå° ngForm ç controls çååï¼æèæ¯ææ²¡ææ¾å°\n        // éªè¯çæ¶åå¾ªç¯ ngForm ç controls éªè¯\n        // åç°æ²¡æ validation åå§åä¸ä¸ªï¼å·²ç»å­å¨ä¸ä¼éæ°åå§åï¼ä¿å­ç¼å­æ°æ®\n        const controls = this._getControls();\n        for (const name in controls) {\n            if (controls.hasOwnProperty(name)) {\n                this._tryGetValidation(name);\n                this.validateControl(name);\n            }\n        }\n        // ç§»é¤å·²ç»ä¸å­å¨ç validation\n        const names = Object.keys(this.validations);\n        names.forEach(name => {\n            if (!controls[name]) {\n                delete this.validations[name];\n            }\n        });\n    }\n\n    validate($event?: Event): boolean {\n        this._ngForm.onSubmit($event);\n        this.validateControls();\n        return this._ngForm.valid;\n    }\n\n    reset() {\n        this._ngForm.reset();\n        for (const name in this.validations) {\n            if (this.validations.hasOwnProperty(name)) {\n                this._restFormControlValidation(name);\n                this._clearElementError(name);\n            }\n        }\n    }\n\n    markControlAsError(name: string, message: string) {\n        this._clearElementError(name);\n        this._setControlValidationError(name, [message]);\n    }\n}\n","import {\n    Directive,\n    OnInit,\n    NgZone,\n    Renderer2,\n    ElementRef,\n    Input,\n    OnDestroy,\n    ContentChildren,\n    AfterContentInit,\n    QueryList\n} from '@angular/core';\nimport { NgxFormValidatorService } from '../validator.service';\nimport { NgForm, ControlContainer, NgControl } from '@angular/forms';\nimport { NgxValidatorConfig } from '../validator.class';\n\nconst KEY_CODES_ENTER = 13;\n\n// 1. submit æ Enter é®æäº¤, Textare é¤å¤ï¼éè¦æ Ctrl | Command + Enter æäº¤\n// 2. alwaysSubmit ä¸ç®¡æ¯åªä¸ªåç´  æ Enter é®é½æäº¤\n// 3. forbidSubmit \bEnter é®ç¦æ­¢æäº¤\n// é»è®¤ submit\nexport enum NgxEnterKeyMode {\n    submit = 'submit',\n    alwaysSubmit = 'alwaysSubmit',\n    forbidSubmit = 'forbidSubmit'\n}\n\n@Directive({\n    selector: 'form[ngxFormValidator],form[ngx-form-validator]',\n    providers: [NgxFormValidatorService],\n    exportAs: 'ngxFormValidator'\n})\nexport class NgxFormValidatorDirective implements OnInit, AfterContentInit, OnDestroy {\n    @ContentChildren(NgControl, {\n        descendants: true\n    })\n    public controls: QueryList<NgControl>;\n\n    private unsubscribe: () => void;\n\n    onSubmitSuccess: ($event: any) => void;\n\n    @Input() enterKeyMode: NgxEnterKeyMode;\n\n    @Input()\n    set ngxFormValidatorConfig(config: NgxValidatorConfig) {\n        this.validator.setValidatorConfig(config);\n    }\n\n    @Input()\n    set ngxFormValidator(config: NgxValidatorConfig) {\n        this.validator.setValidatorConfig(config);\n    }\n\n    get validator() {\n        return this._validator;\n    }\n\n    constructor(\n        private ngZone: NgZone,\n        private renderer: Renderer2,\n        private elementRef: ElementRef,\n        private _validator: NgxFormValidatorService,\n        private ngForm: ControlContainer\n    ) {}\n\n    ngOnInit() {\n        this.ngZone.runOutsideAngular(() => {\n            this.unsubscribe = this.renderer.listen(\n                this.elementRef.nativeElement,\n                'keydown',\n                this.onKeydown.bind(this)\n            );\n        });\n\n        this.validator.initialize(this.ngForm as NgForm, this.elementRef.nativeElement);\n    }\n\n    ngAfterContentInit() {\n        this.validator.initializeFormControlsValidation(this.controls.toArray());\n        this.controls.changes.subscribe(controls => {\n            this.validator.initializeFormControlsValidation(this.controls.toArray());\n        });\n    }\n\n    submit($event: Event) {\n        if (this.validator.validate($event) && this.onSubmitSuccess) {\n            this.onSubmitSuccess($event);\n        }\n    }\n\n    submitRunInZone($event: Event) {\n        this.ngZone.run(() => {\n            this.submit($event);\n        });\n    }\n\n    onKeydown($event: KeyboardEvent) {\n        const currentInput = document.activeElement;\n        const key = $event.which || $event.keyCode;\n        if (key === KEY_CODES_ENTER && currentInput.tagName) {\n            if (!this.enterKeyMode || this.enterKeyMode === NgxEnterKeyMode.submit) {\n                // TEXTAREA Ctrl + Enter æè Command + Enter é»æ­¢\bé»è®¤è¡ä¸ºå¹¶æäº¤\n                if (currentInput.tagName === 'TEXTAREA') {\n                    if ($event.ctrlKey || $event.metaKey) {\n                        $event.preventDefault();\n                        this.submitRunInZone($event);\n                    }\n                } else {\n                    // ä¸æ¯ TEXTAREA Enter é»æ­¢\bé»è®¤è¡ä¸ºå¹¶æäº¤\n                    $event.preventDefault();\n                    this.submitRunInZone($event);\n                }\n            } else if (this.enterKeyMode === NgxEnterKeyMode.alwaysSubmit) {\n                $event.preventDefault();\n                this.submitRunInZone($event);\n            } else {\n                // do nothing\n            }\n        }\n    }\n\n    ngOnDestroy(): void {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n        }\n    }\n}\n","import { Directive, ElementRef, Output, OnInit, HostBinding, HostListener, Optional, EventEmitter } from '@angular/core';\nimport { NgForm } from '@angular/forms';\nimport { NgxFormValidatorDirective } from './form-validator.directive';\n\n@Directive({\n    selector: '[ngxFormSubmit],[ngx-form-submit]'\n})\nexport class NgxFormSubmitDirective implements OnInit {\n\n    @Output() ngxFormSubmit = new EventEmitter();\n\n    constructor(\n        private validatorDirective: NgxFormValidatorDirective\n    ) {\n    }\n\n    ngOnInit(): void {\n        this.validatorDirective.onSubmitSuccess = ($event: any) => {\n            this.ngxFormSubmit.emit($event);\n        };\n    }\n\n    @HostListener('click', ['$event'])\n    onSubmit($event: any) {\n        this.validatorDirective.submit($event);\n    }\n}\n","import { AbstractControl, ValidationErrors } from '@angular/forms';\nimport { of, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport class NgxValidators {\n    static uniqueCheckValidator(uniqueCheckFn: (value: any) => Observable<boolean>) {\n        const result = (\n            control: AbstractControl\n        ): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> => {\n            if (control.value) {\n                return uniqueCheckFn(control.value).pipe(\n                    map(isUnique => {\n                        return isUnique ? { ngxUniqueCheck: { value: true } } : null;\n                    })\n                );\n            } else {\n                return of(null);\n            }\n        };\n        return result;\n    }\n}\n","import { Directive, forwardRef, Attribute, Injectable, ElementRef, Input } from '@angular/core';\nimport {\n    NG_VALIDATORS,\n    Validator,\n    AbstractControl,\n    Validators,\n    ValidatorFn,\n    NG_ASYNC_VALIDATORS,\n    AsyncValidator,\n    ValidationErrors\n} from '@angular/forms';\nimport { Observable, of } from 'rxjs';\nimport { NgxValidators } from '../validators';\n\n@Directive({\n    selector:\n        '[ngxMin][formControlName],[ngxMin][formControl],[ngxMin][ngModel],',\n    providers: [\n        {\n            provide: NG_VALIDATORS,\n            useExisting: forwardRef(() => MinValidatorDirective),\n            multi: true\n        }\n    ]\n})\nexport class MinValidatorDirective implements Validator {\n    private validator: ValidatorFn;\n\n    @Input() public set ngxMin(value: string) {\n        this.validator = Validators.min(parseFloat(value));\n    }\n\n    constructor() {}\n\n    validate(control: AbstractControl) {\n        return this.validator(control);\n    }\n}\n\n@Directive({\n    selector:\n        '[ngxMax][formControlName],[ngxMax][formControl],[ngxMax][ngModel]',\n    providers: [\n        {\n            provide: NG_VALIDATORS,\n            useExisting: forwardRef(() => MaxValidatorDirective),\n            multi: true\n        }\n    ]\n})\nexport class MaxValidatorDirective implements Validator {\n    private validator: ValidatorFn;\n\n    @Input() public set ngxMax(value: string) {\n        this.validator = Validators.max(parseFloat(value));\n    }\n\n    constructor() {}\n\n    validate(control: AbstractControl) {\n        return this.validator(control);\n    }\n}\n\n@Directive({\n    selector: '[ngxUniqueCheck][formControlName],[ngxUniqueCheck][formControl],[ngxUniqueCheck][ngModel]',\n    providers: [\n        {\n            provide: NG_ASYNC_VALIDATORS,\n            useExisting: NgxUniqueCheckDirective,\n            multi: true\n        }\n    ]\n})\nexport class NgxUniqueCheckDirective implements AsyncValidator {\n    @Input() ngxUniqueCheck: (value: any) => Observable<boolean | null> = (value: any) => of(null);\n\n    constructor() {}\n\n    validate(control: AbstractControl): Promise<ValidationErrors> | Observable<ValidationErrors> {\n        return NgxValidators.uniqueCheckValidator(this.ngxUniqueCheck)(control);\n    }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { NgxFormValidatorDirective } from './directives/form-validator.directive';\nimport { NgxFormSubmitDirective } from './directives/form-submit.directive';\n\n// import { NgxUniqueCheckDirective } from './directives/form-unique-check.directive';\nimport { MaxValidatorDirective, MinValidatorDirective, NgxUniqueCheckDirective } from './directives/validators';\n\nimport { NgxValidatorGlobalConfig, NGX_VALIDATOR_CONFIG } from './validator.class';\n\nconst declarations = [\n    NgxFormValidatorDirective,\n    NgxFormSubmitDirective,\n    NgxUniqueCheckDirective,\n    MaxValidatorDirective,\n    MinValidatorDirective\n];\n\n@NgModule({\n    declarations: declarations,\n    imports: [FormsModule],\n    exports: [...declarations, FormsModule]\n})\nexport class NgxValidatorModule {\n    static forRoot(config: NgxValidatorGlobalConfig): ModuleWithProviders {\n        return {\n            ngModule: NgxValidatorModule,\n            providers: [\n                {\n                    provide: NGX_VALIDATOR_CONFIG,\n                    useValue: config\n                }\n            ]\n        };\n    }\n}\n"]}